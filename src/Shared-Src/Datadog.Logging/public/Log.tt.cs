// <auto-generated />
// ----------- ----------- ----------- ----------- -----------
// The source code below is included via a T4 template.
//  * The template calling MUST specify the value of the <c>LogNamespaceName</c> meta-variable.
//  * The template calling MAY specify the value of the <c>LogClassAccessibilityLevel</c> meta-variable,
//    however its default value "public" is the appropriate choice in most cases
//    (other values would prevent composability by other assemblies).
// ----------- ----------- ----------- ----------- -----------
<#@ parameter type="System.String" name="LogNamespaceName" #>
<# string LogNamespace = LogNamespaceName ?? "LogNamespaceName"; #>
<#@ parameter type="System.String" name="LogClassAccessibilityLevel" #>
<# string LogClassAccessibility = LogClassAccessibilityLevel ?? "public"; #>

using System;
using System.Runtime.CompilerServices;

namespace <#= LogNamespace #>
{
    /// <summary>
    /// Leightweight Log stub for Logging-SDK-agnostic logging.
    /// Users of this library can use this class as a leighweight redirect to whatever log technology is used for output.
    /// This allows to avoid creating complex logging abstractions (or taking dependencies on ILogger) for now.
    /// We copy this simply class to each assembly once, becasue we need to change the namespace to avoid ambuguity.
    /// 
    /// For example:
    /// 
    /// Library "Datadog.AutoInstrumentation.Profiler.Managed.dll" gets a copy of this file with the adjusted namespace:
    /// 
    /// <code>
    ///   namespace Datadog.AutoInstrumentation.Profiler.Managed
    ///   {
    ///       public static class Log
    ///       {
    ///       . . .
    ///       }
    ///   }
    /// </code>
    /// 
    /// Library "Datadog.AutoInstrumentation.Tracer.Managed.dll" gets a copy of this file with the adjusted namespace:
    /// 
    /// <code>
    ///   namespace Datadog.AutoInstrumentation.Tracer.Managed
    ///   {
    ///       public static class Log
    ///       {
    ///       . . .
    ///       }
    ///   }
    /// </code>  
    /// 
    /// Each librry can now make Log statements, for example:
    /// 
    /// <code>
    ///   Log.Info("DataExporter", "Data transport started", "size", _size, "otherAttribute", _otherAttribute);
    /// </code>  
    /// 
    /// Another composing library "Datadog.AutoInstrumentation.ProductComposer.dll" the uses the two above libraries uses some particular logging system.
    /// It wants to redirect the logs of its components accordingly.
    /// It creates a trivial adaper and configures the indirection:
    /// 
    /// <code>
    ///   namespace Datadog.AutoInstrumentation.ProductComposer
    ///   {
    ///       using ComposerLogAdapter = Datadog.AutoInstrumentation.ProductComposer.LogAdapter;
    ///       using ProfilerLog = Datadog.AutoInstrumentation.Profiler.Managed.Log;
    ///       using TracerLog = Datadog.AutoInstrumentation.Tracer.Managed.Log;
    ///       
    ///       internal static class LogAdapter
    ///       {
    ///           static LogAdapter()
    ///           {
    ///               // Redirect the logs from the libraries being composed to the coposer's processors:
    ///   
    ///               ProfilerLog.Configure.Error((component, msg, ex, data) => ComposerLogAdapter.Error("Profiler", component, msg, ex, data));
    ///               ProfilerLog.Configure.Info((component, msg, data) => ComposerLogAdapter.Info("Profiler", component, msg, data));
    ///               ProfilerLog.Configure.Debug((component, msg, data) => ComposerLogAdapter.Debug("Profiler", component, msg, data));
    ///               ProfilerLog.Configure.DebugLoggingEnabled(ComposerLogAdapter.IsDebugLoggingEnabled);
    ///   
    ///               TracerLog.Configure.Error((component, msg, rx, data) => ComposerLogAdapter.ErrorMessage("Tracer", component, msg, ex, data));
    ///               TracerLog.Configure.Info((component, msg, data) => ComposerLogAdapter.Info("Tracer", component, msg, data));
    ///               TracerLog.Configure.Debug((component, msg, data) => ComposerLogAdapter.Debug("Tracer", component, msg, data));
    ///               TracerLog.Configure.DebugLoggingEnabled(ComposerLogAdapter.IsDebugLoggingEnabled);
    ///           }
    ///   
    ///           public const bool IsDebugLoggingEnabled = true;
    ///           
    ///           public static void Error(string componentGroupName, string componentName, string message, Exception exception, params object[] dataNamesAndValues)
    ///           {
    ///               // Prepare a log line in any appropriate way. For example:
    ///               StringBuilder logLine = ProfilerLog.DefaultFormat.ConstructLogLine(
    ///                                               ProfilerLog.DefaultFormat.LogLevelMoniker_Error,
    ///                                               componentGroupName,
    ///                                               "::",
    ///                                               componentName,
    ///                                               useUtcTimestamp: false,
    ///                                               Log.DefaultFormat.ConstructErrorMessage(message, exception),
    ///                                               dataNamesAndValues);
    ///               // Persist logLine to file...
    ///           }
    ///   
    ///           public static void Info(string componentGroupName, string componentName, string message, params object[] dataNamesAndValues)
    ///           {
    ///               // Prepare a log line (e.g. like above) and persist it to file...
    ///           }
    ///
    ///           public static void Debug(string componentGroupName, string componentName, string message, params object[] dataNamesAndValues)
    ///           {
    ///               // Prepare a log line (e.g. like above) and persist it to file...
    ///           }
    ///       }
    ///   }
    /// </code>
    /// </summary>
    <#= LogClassAccessibility #> static class Log
    {
        /// <summary>
        /// Use statements like <c>Log.Configure.Info(YourHandler)</c> to redirect logging to your destination.
        /// </summary>
        public static class Configure
        {
            /// <summary>
            /// Sets the handler delegate for processing Error log events.
            /// If <c>null</c> is specified, then Error log events will be ignored.
            /// </summary>
            public static void Error(Action<string, string, Exception, object[]> logEventHandler)
            {
                s_errorLogEventHandler = logEventHandler;
            }

            /// <summary>
            /// Sets the handler delegate for processing Info log events.
            /// If <c>null</c> is specified, then Error log events will be ignored.
            /// </summary>
            public static void Info(Action<string, string, object[]> logEventHandler)
            {
                s_infoLogEventHandler = logEventHandler;
            }

            /// <summary>
            /// Sets the handler delegate for processing Debug log events.
            /// If <c>null</c> is specified, then Error log events will be ignored.
            /// </summary>
            public static void Debug(Action<string, string, object[]> logEventHandler)
            {
                s_debugLogEventHandler = logEventHandler;
            }

            /// <summary>
            /// Sets whether Debug log events should be processed or ignored.
            /// </summary>
            public static void DebugLoggingEnabled(bool isDebugLoggingEnabled)
            {
                s_isDebugLoggingEnabled = isDebugLoggingEnabled;
            }
        }  // class Log.Configure

        private static Action<string, string, Exception, object[]> s_errorLogEventHandler = global::Datadog.Logging.Emission.SimpleConsoleSink.Error;
        private static Action<string, string, object[]> s_infoLogEventHandler = global::Datadog.Logging.Emission.SimpleConsoleSink.Info;
        private static Action<string, string, object[]> s_debugLogEventHandler = global::Datadog.Logging.Emission.SimpleConsoleSink.Debug;
        private static bool s_isDebugLoggingEnabled = global::Datadog.Logging.Emission.SimpleConsoleSink.IsDebugLoggingEnabled;

        /// <summary>
        /// Gets whether debug log messages should be processed or ignored.
        /// Consider wrapping debug message invocations into IF statements that check for this
        /// value in order to avoid unnecessarily constructing debug message strings.
        /// </summary>
        public static bool IsDebugLoggingEnabled
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return s_isDebugLoggingEnabled; }
        }

        /// <summary>
        /// Logs an error.
        /// These need to be persisted well, so that the info is available for support cases.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Error(string componentName, string message, params object[] dataNamesAndValues)
        {
            Error(componentName, message, exception: null, dataNamesAndValues);
        }

        /// <summary>
        /// Logs an error.
        /// These need to be persisted well, so that the info is available for support cases.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Error(string componentName, Exception exception, params object[] dataNamesAndValues)
        {
            Error(componentName, message: null, exception, dataNamesAndValues);
        }

        /// <summary>
        /// Logs an error.
        /// These need to be persisted well, so that the info is available for support cases.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Error(string componentName, string message, Exception exception, params object[] dataNamesAndValues)
        {
            Action<string, string, Exception, object[]> logEventHandler = s_errorLogEventHandler;
            if (logEventHandler != null)
            {
                logEventHandler(componentName, message, exception, dataNamesAndValues);
            }
        }

        /// <summary>
        /// Logs an important info message.
        /// These need to be persisted well, so that the info is available for support cases.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Info(string componentName, string message, params object[] dataNamesAndValues)
        {
            Action<string, string, object[]> logEventHandler = s_infoLogEventHandler;
            if (logEventHandler != null)
            {
                logEventHandler(componentName, message, dataNamesAndValues);
            }
        }

        /// <summary>
        /// Logs a non-critical info message. Mainly used for for debugging during prototyping.
        /// These messages can likely be dropped in production.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Debug(string componentName, string message, params object[] dataNamesAndValues)
        {
            if (IsDebugLoggingEnabled)
            { 
                Action<string, string, object[]> logEventHandler = s_debugLogEventHandler;
                if (logEventHandler != null)
                {
                    logEventHandler(componentName, message, dataNamesAndValues);
                }
            }
        }
    }  // class Log
}  // namespace
