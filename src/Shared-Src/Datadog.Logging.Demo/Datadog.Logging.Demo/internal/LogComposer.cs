// <auto-generated />
// This .CS file is automatically generated. If you modify its contents, your changes will be overwritten.
// Modify the respective T4 templates if changes are required.

// <auto-generated />
// ----------- ----------- ----------- ----------- -----------
// The source code below is included via a T4 template.
// The template calling must specify the value of the <c>NamespacesAndMonikersOfLogsToCompose</c> meta-variable.
// ----------- ----------- ----------- ----------- -----------

using System;

namespace Datadog.Logging.Composition
{
    /// <summary>
    /// Collects data from many Log-sources and sends it to the specified Log Sink.
    /// This class has been generated using a T4 template. It covers the following logging components:
    ///   1) Logger type:               "Datadog.Logging.Demo.Log"
    ///      Logging component moniker: "LoggingDemo"
    ///
    /// TOTAL: 1 loggers.
    /// </summary>
    internal static class LogComposer
    {
        private const string IsDebugLoggingEnabledEnvVarName = "DD_TRACE_DEBUG";

        private static bool s_isDebugLoggingEnabled = true;

        public static bool IsDebugLoggingEnabled
        {
            get
            {
                return s_isDebugLoggingEnabled;
            }

            set
            {
                s_isDebugLoggingEnabled = value;
                {
                    global::Datadog.Logging.Demo.Log.Configure.DebugLoggingEnabled(s_isDebugLoggingEnabled);
                }
            }
        }

        public static void SetDebugLoggingEnabledBasedOnEnvironment()
        {
            bool envSetting = GetDebugLoggingEnabledEnvironmentSetting();
            IsDebugLoggingEnabled = envSetting;
        }

        public static void RedirectLogs(ILogSink logSink)
        {
            {
                Datadog.Logging.Demo.Log.Configure.DebugLoggingEnabled(IsDebugLoggingEnabled);

                if (logSink == null)
                {
                    global::Datadog.Logging.Demo.Log.Configure.Error(null);
                    global::Datadog.Logging.Demo.Log.Configure.Info(null);
                    global::Datadog.Logging.Demo.Log.Configure.Debug(null);
                }
                else
                {
                    global::Datadog.Logging.Demo.Log.Configure.Error((component, msg, ex, data) => TryLogError(logSink, "LoggingDemo", component, msg, ex, data));
                    global::Datadog.Logging.Demo.Log.Configure.Info((component, msg, data) => TryLogInfo(logSink, "LoggingDemo", component, msg, data));
                    global::Datadog.Logging.Demo.Log.Configure.Debug((component, msg, data) => TryLogDebug(logSink, "LoggingDemo", component, msg, data));
                }
            }
        }

        private static bool GetDebugLoggingEnabledEnvironmentSetting()
        {
            // Unless the debug log is explicitly disabled, we assume that it is enabled.
            try
            {
                string IsDebugLoggingEnabledEnvVarValue = ReadEnvironmentVariable(IsDebugLoggingEnabledEnvVarName);

                if (IsDebugLoggingEnabledEnvVarValue != null)
                {
                    if (IsDebugLoggingEnabledEnvVarValue.Equals("false", System.StringComparison.OrdinalIgnoreCase)
                            || IsDebugLoggingEnabledEnvVarValue.Equals("no", System.StringComparison.OrdinalIgnoreCase)
                            || IsDebugLoggingEnabledEnvVarValue.Equals("n", System.StringComparison.OrdinalIgnoreCase)
                            || IsDebugLoggingEnabledEnvVarValue.Equals("f", System.StringComparison.OrdinalIgnoreCase)
                            || IsDebugLoggingEnabledEnvVarValue.Equals("0", System.StringComparison.OrdinalIgnoreCase))
                    {
                        return false;
                    }
                }
            }
            catch
            { }
            
            return true;
        }

        private static bool TryLogError(ILogSink logSink, string logComponentGroupMoniker, string logComponentMoniker, string message, Exception error, object[] dataNamesAndValues)
        {
            return logSink.TryLogError(LoggingComponentName.Create(logComponentGroupMoniker, logComponentMoniker), message, error, dataNamesAndValues);
        }

        private static bool TryLogInfo(ILogSink logSink, string logComponentGroupMoniker, string logComponentMoniker, string message, object[] dataNamesAndValues)
        {
            return logSink.TryLogInfo(LoggingComponentName.Create(logComponentGroupMoniker, logComponentMoniker), message, dataNamesAndValues);
        }

        private static bool TryLogDebug(ILogSink logSink, string logComponentGroupMoniker, string logComponentMoniker, string message, object[] dataNamesAndValues)
        {
            if (IsDebugLoggingEnabled)
            { 
                return logSink.TryLogDebug(LoggingComponentName.Create(logComponentGroupMoniker, logComponentMoniker), message, dataNamesAndValues);
            }

            return false;
        }

        private static string ReadEnvironmentVariable(string envVarName)
        {
            try
            {
                return Environment.GetEnvironmentVariable(envVarName);
            }
            catch
            {
                return null;
            }
        }
    }
}
